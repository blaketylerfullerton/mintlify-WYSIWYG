import { Note, Callout, CardProp, Code, AccordionGroup, Accordion, Tip, Columns } from "./custom-components";
import { Input } from "./ui/input";
import { Button } from "./ui/button";
import { Card as UICard } from "./ui/card";

// Enhanced custom component parser that works with ReactMarkdown
export function parseCustomComponents(markdown: string): string {
  // Replace custom component syntax with HTML-like syntax that ReactMarkdown can handle
  let processed = markdown;

  try {
    // Handle custom code blocks with filename: ```language filename
    const codeRegex = /```(\w+)(?:\s+([^\n]+))?\n([\s\S]*?)```/g;
    processed = processed.replace(
      codeRegex,
      (_match, language, filename, content) => {
        return `<div data-component="code" data-language="${language}" data-filename="${
          filename || ""
        }">${content?.trim() || ""}</div>`;
      }
    );

    // Handle nested components more robustly
    // First, handle <AccordionGroup> with nested <Accordion> components
    processed = processNestedComponents(processed, 'AccordionGroup', (content: string) => {
      // Process nested Accordion components within the group
      return processNestedComponents(content, 'Accordion', (accordionContent: string, attributes?: string) => {
        const attrs = parseJSXAttributes(attributes || "");
        const icon = attrs.icon || "chevron-right";
        const title = attrs.title || "";
        return `<div data-component="accordion" data-icon="${icon}" data-title="${title}">${accordionContent}</div>`;
      });
    });

    // Handle standalone <Accordion> components (outside of groups)
    processed = processNestedComponents(processed, 'Accordion', (content: string, attributes?: string) => {
      const attrs = parseJSXAttributes(attributes || "");
      const icon = attrs.icon || "chevron-right";
      const title = attrs.title || "";
      return `<div data-component="accordion" data-icon="${icon}" data-title="${title}">${content}</div>`;
    });

    // Handle <Tip> syntax
    const tipRegex = /<Tip>\s*([\s\S]*?)<\/Tip>/g;
    processed = processed.replace(tipRegex, (_match, content) => {
      return `<div data-component="tip">${content?.trim() || ""}</div>`;
    });

    // Handle <Note> syntax
    const noteRegex = /<Note(?:\s+([^>]*))?\s*>([\s\S]*?)<\/Note>/g;
    processed = processed.replace(noteRegex, (_match, attributes, content) => {
      const attrs = parseJSXAttributes(attributes || "");
      const type = attrs.type || "info";
      const title = attrs.title || "";

      return `<div data-component="note" data-type="${type}" data-title="${title}">${
        content?.trim() || ""
      }</div>`;
    });

    // Handle :::note syntax (generated by the toolbar)
    const noteColonRegex = /:::note(?:\s+([^:\n]+))?\n([\s\S]*?)\n:::/g;
    processed = processed.replace(
      noteColonRegex,
      (_match, attributes, content) => {
        const attrs = parseAttributes(attributes || "");
        const type = attrs.type || "info";
        const title = attrs.title || "";

        return `<div data-component="note" data-type="${type}" data-title="${title}">${
          content?.trim() || ""
        }</div>`;
      }
    );

    // Handle <Card> syntax
    const cardRegex = /<Card(?:\s+([^>]*))?\s*>([\s\S]*?)<\/Card>/g;
    processed = processed.replace(cardRegex, (_match, attributes, content) => {
      const attrs = parseJSXAttributes(attributes || "");
      const title = attrs.title || "";
      const icon = attrs.icon || "";
      const href = attrs.href || "";

      return `<div data-component="card" data-title="${title}" data-icon="${icon}" data-href="${href}">${
        content?.trim() || ""
      }</div>`;
    });

    // Handle <Columns> ... </Columns>
    processed = processNestedComponents(processed, 'Columns', (content: string, attributes?: string) => {
      const attrs = parseJSXAttributes(attributes || "");
      const cols = attrs.cols || "2";
      const gap = attrs.gap || "16";
      return `<div data-component="columns" data-cols="${cols}" data-gap="${gap}">${content}</div>`;
    });

    // Generic component passthrough for any known component name
    processed = transformGenericComponents(processed, Object.keys(componentRegistry));
  } catch (error) {
    console.error("Error parsing custom components:", error);
    return markdown; // Return original markdown if parsing fails
  }

  return processed;
}

// Helper function to process nested components more robustly
function processNestedComponents(
  content: string, 
  componentName: string, 
  processor: (content: string, attributes?: string) => string
): string {
  const regex = new RegExp(`<${componentName}(?:\\s+([^>]*))?\\s*>([\\s\\S]*?)<\\/${componentName}>`, 'g');
  
  return content.replace(regex, (_match, attributes, innerContent) => {
    return processor(innerContent?.trim() || "", attributes);
  });
}

// Parse JSX-style attributes from string like: title="Plant Store Endpoints" icon="leaf" href="..."
function parseJSXAttributes(attributeString: string): Record<string, string> {
  const attrs: Record<string, string> = {};
  const regex = /(\w+)="([^"]*)"/g;
  let match;

  while ((match = regex.exec(attributeString)) !== null) {
    attrs[match[1]] = match[2];
  }

  return attrs;
}

// Parse attributes from string like: type="warning" title="Important Note"
function parseAttributes(attributeString: string): Record<string, string> {
  const attrs: Record<string, string> = {};
  const regex = /(\w+)="([^"]*)"/g;
  let match;

  while ((match = regex.exec(attributeString)) !== null) {
    attrs[match[1]] = match[2];
  }

  return attrs;
}

// Registry of components that can be invoked by name from markdown, e.g. <Input />, <Button />
const componentRegistry: Record<string, React.ComponentType<any>> = {
  // UI components
  Input,
  Button,
  Card: UICard,
  // Custom components
  Note,
  Callout,
  Accordion,
  AccordionGroup,
  Tip,
};

// Replace JSX-like tags for known components with data-* placeholders ReactMarkdown can handle
function transformGenericComponents(markdown: string, allowedNames: string[]): string {
  // Block form: <Name a="b">children</Name>
  const blockRegex = new RegExp(
    `<(${allowedNames.join("|")})(?:\\s+([^>]*))?\\s*>([\\s\\S]*?)<\\/\\1>`,
    "g"
  );

  let output = markdown.replace(blockRegex, (_m, name, attributes, inner) => {
    const attrs = parseJSXAttributes(attributes || "");
    const dataProps = Object.entries(attrs)
      .map(([k, v]) => `data-prop-${k}="${escapeHtmlAttr(v)}"`)
      .join(" ");

    return `<div data-component="generic" data-name="${name}" ${dataProps}>${
      inner?.trim() || ""
    }</div>`;
  });

  // Self-closing form: <Name a="b" />
  const selfClosingRegex = new RegExp(
    `<(${allowedNames.join("|")})(?:\\s+([^/>]*))?\\s*/>`,
    "g"
  );

  output = output.replace(selfClosingRegex, (_m, name, attributes) => {
    const attrs = parseJSXAttributes(attributes || "");
    const dataProps = Object.entries(attrs)
      .map(([k, v]) => `data-prop-${k}="${escapeHtmlAttr(v)}"`)
      .join(" ");

    return `<div data-component="generic" data-name="${name}" ${dataProps}></div>`;
  });

  return output;
}

function escapeHtmlAttr(value: string): string {
  return value
    .replace(/&/g, "&amp;")
    .replace(/"/g, "&quot;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

// Enhanced custom component renderer for ReactMarkdown
export const customComponentRenderer = {
  div: ({ node, children, ...props }: any) => {
    const component = props["data-component"];

    if (component === "generic") {
      const name = props["data-name"] as string;
      const Component = componentRegistry[name];
      if (!Component) {
        return <div {...props}>{children}</div>;
      }

      // Extract props from data-prop-*
      const componentProps: Record<string, any> = {};
      Object.keys(props)
        .filter((key) => key.startsWith("data-prop-"))
        .forEach((key) => {
          const propName = key.replace("data-prop-", "");
          componentProps[propName] = props[key];
        });

      return <Component {...componentProps}>{children}</Component>;
    }

    if (component === "accordion-group") {
      return (
        <AccordionGroup>
          {children}
        </AccordionGroup>
      );
    }

    if (component === "accordion") {
      const icon = props["data-icon"];
      const title = props["data-title"];

      return (
        <Accordion icon={icon} title={title}>
          {children}
        </Accordion>
      );
    }

    if (component === "tip") {
      return (
        <Tip>
          {children}
        </Tip>
      );
    }

    if (component === "code") {
      const language = props["data-language"];
      const filename = props["data-filename"];

      return (
        <Code language={language} filename={filename}>
          {children}
        </Code>
      );
    }

    if (component === "note") {
      const type = props["data-type"] as
        | "info"
        | "warning"
        | "success"
        | "error";
      const title = props["data-title"];

      return (
        <Note type={type} title={title}>
          {children}
        </Note>
      );
    }

    if (component === "card") {
      const title = props["data-title"];
      const icon = props["data-icon"];
      const href = props["data-href"];

      return (
        <CardProp title={title} icon={icon} href={href}>
          {children}
        </CardProp>
      );
    }

    if (component === "columns") {
      const cols = props["data-cols"];
      const gap = props["data-gap"];
      return <Columns cols={Number(cols)} gap={Number(gap)}>{children}</Columns>;
    }

    if (component === "callout") {
      const emoji = props["data-emoji"];
      const title = props["data-title"];

      return (
        <Callout emoji={emoji} title={title}>
          {children}
        </Callout>
      );
    }

    // Default div rendering
    return <div {...props}>{children}</div>;
  },
};
